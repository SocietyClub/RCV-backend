/*
 * Ranked Choice Voting API
 *
 * This is the API for Creating, Managing and Fetching Polls and Votes for the RCV Project.
 *
 * API version: 1.0.0-dev
 * Contact: teamsocietyclub@gmail.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"errors"
	"fmt"
	"net/http"

	"cloud.google.com/go/firestore"
)

// VotesApiService is a service that implents the logic for the VotesApiServicer
// This service should implement the business logic for every endpoint for the VotesApi API.
// Include any external packages or services that will be required by this service.
type VotesApiService struct {
}

// NewVotesApiService creates a default api service
func NewVotesApiService() VotesApiServicer {
	return &VotesApiService{}
}

const (
	votesCollectionName string = "votes"
)

// PollPollIDVotePost - Cast a vote for a specific Poll
func (s *VotesApiService) PollPollIDVotePost(ctx context.Context, xUSERID string, pollID string, voteInput VoteInput) (ImplResponse, error) {
	var messages Messages
	var addPollResponse AddPollResponse

	if !IsValidUUID(xUSERID) {
		err := errors.New("xUSERID is not valid UUID")
		AddMessage(&messages, Severity(ERROR), "Request Param issue", fmt.Sprintf("Vote could not be posted: %s", err))
		addPollResponse.Messages = messages
		return Response(http.StatusBadRequest, addPollResponse), err
	}

	context_background := context.Background()
	firestore_client := GetFirestoreClient(context_background)

	// Closes client after function returns a value
	defer firestore_client.Close()

	votedoc := firestore_client.Collection(votesCollectionName).Doc(pollID)
	// TODO: add checks to ensure the vote is valid.

	err := firestore_client.RunTransaction(ctx, func(ctx context.Context, tx *firestore.Transaction) error {
		return tx.Set(votedoc, map[string]interface{}{
			xUSERID: voteInput.Choices,
		}, firestore.MergeAll)
	})

	if err != nil {
		AddMessage(&messages, Severity(ERROR), "Database transaction failure", fmt.Sprintf("Vote could not be posted: %s", err))
		addPollResponse.Messages = messages
		return Response(http.StatusInternalServerError, addPollResponse), err
	}

	return Response(http.StatusOK, voteInput), nil

}
