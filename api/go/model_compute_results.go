/*
 * Ranked Choice Voting API
 *
 * This is the API for Creating, Managing and Fetching Polls and Votes for the RCV Project.
 *
 * API version: 1.0.0-dev
 * Contact: teamsocietyclub@gmail.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

type PollComputeVote struct {
	candidateChoices []string
}

type PollComputeCandidate struct {
	candidate    Candidate
	eliminated   bool
	currentVotes []PollComputeVote
}

type PollVoteDistributionDataPoint struct {
	FirstChoiceCandidate string `json:"firstChoiceCandidate,omitempty"`
	VoteCount            uint64 `json:"voteCount,omitempty"`
}

type PollCandidateResults struct {
	Name             string                          `json:"name,omitempty"`
	Eliminated       bool                            `json:"eliminated,omitempty"`
	VoteDistribution []PollVoteDistributionDataPoint `json:"voteDistribution,omitempty"`
}

type PollResultStep struct {
	StepId        int64                  `json:"stepId,omitempty"`
	CandidateList []PollCandidateResults `json:"candidateList,omitempty"`
}

type PollResults struct {
	PollId       int64            `json:"pollId,omitempty"`
	TotalEntries int32            `json:"totalEntries,omitempty"`
	TotalSteps   int32            `json:"totalSteps,omitempty"`
	Winner       string           `json:"winner,omitempty"`
	Steps        []PollResultStep `json:"steps,omitempty"`
	YourEntry    []VoteInput      `json:"yourEntry,omitempty"`
}

func ProcessPollSteps(candidates []Candidate, votes []VoteInput) PollResults {
	computeVotes := make([]PollComputeVote, len(votes))
	for i := 0; i < len(votes); i++ {
		computeVotes[i] = toComputeVote(votes[i])
	}
	return processPollStepsImpl(candidates, computeVotes)
}

func toComputeVote(vote VoteInput) PollComputeVote {
	candidateChoices := make([]string, len(vote.Choices))
	// Todo: this is garbage, actually check for this with proper mapping.
	for i := 0; i < len(vote.Choices); i++ {
		candidateChoices[vote.Choices[i].ChoicePosition] = vote.Choices[i].Candidate.Name
	}
	computeVote := PollComputeVote{candidateChoices}
	return computeVote
}

func processPollStepsImpl(candidates []Candidate, votes []PollComputeVote) PollResults {
	candidateMap := make(map[string]PollComputeCandidate)
	for _, candidate := range candidates {
		candidateMap[candidate.Name] = PollComputeCandidate{candidate, false, make([]PollComputeVote, 0)}
	}

	for !isPollDone(candidateMap) {
		candidateMap = iteratePoll(candidateMap, votes)
		pollStep := createPollResultStep(candidateMap)

		// Eliminate candidates
		// Sort PollVoteDistributionDataPoint s
		// refresh candidateMap for the next iteration
	}

	return PollResults{}
}

func isPollDone(candidateMap map[string]PollComputeCandidate) bool {
	return true
}

func iteratePoll(candidateMap map[string]PollComputeCandidate, votes []PollComputeVote) map[string]PollComputeCandidate {
	for _, vote := range votes {
		for _, choice := range vote.candidateChoices {
			if !candidateMap[choice].eliminated {
				computeCandidate := candidateMap[choice]
				computeCandidate.currentVotes = append(computeCandidate.currentVotes, vote)
				candidateMap[choice] = computeCandidate
				break
			}
		}
	}

	return candidateMap
}

func getVoteDistribution(votes []PollComputeVote) []PollVoteDistributionDataPoint {
	distribMap := make(map[string]uint64)
	for _, vote := range votes {
		if _, ok := distribMap[vote.candidateChoices[0]]; ok {
			distribMap[vote.candidateChoices[0]] += 1
		} else {
			distribMap[vote.candidateChoices[0]] = 1
		}
	}

	dataPoints := make([]PollVoteDistributionDataPoint, 0)
	for key, value := range distribMap {
		dataPoints = append(dataPoints, PollVoteDistributionDataPoint{key, value})
	}

	return dataPoints
}

func createPollResultStep(candidateMap map[string]PollComputeCandidate) PollResultStep {

	return PollResultStep{}
}
