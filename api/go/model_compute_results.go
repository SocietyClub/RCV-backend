/*
 * Ranked Choice Voting API
 *
 * This is the API for Creating, Managing and Fetching Polls and Votes for the RCV Project.
 *
 * API version: 1.0.0-dev
 * Contact: teamsocietyclub@gmail.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"fmt"
	"math"
)

type PollComputeVote struct {
	candidateChoices []string
}

type PollComputeCandidate struct {
	candidate    Candidate
	Eliminated   bool
	currentVotes []PollComputeVote
}

type PollVoteDistributionDataPoint struct {
	FirstChoiceCandidate string `json:"firstChoiceCandidate,omitempty"`
	VoteCount            uint64 `json:"voteCount,omitempty"`
}

type PollCandidateResults struct {
	Name             string                          `json:"name,omitempty"`
	Eliminated       bool                            `json:"eliminated,omitempty"`
	VoteDistribution []PollVoteDistributionDataPoint `json:"voteDistribution,omitempty"`
}

type PollResultStep struct {
	StepId        int64                  `json:"stepId,omitempty"`
	CandidateList []PollCandidateResults `json:"candidateList,omitempty"`
}

type PollResults struct {
	PollId       int64            `json:"pollId,omitempty"`
	TotalEntries int32            `json:"totalEntries,omitempty"`
	TotalSteps   int32            `json:"totalSteps,omitempty"`
	Winner       string           `json:"winner,omitempty"`
	Steps        []PollResultStep `json:"steps,omitempty"`
	YourEntry    []VoteInput      `json:"yourEntry,omitempty"`
}

func ProcessPollSteps(candidates []Candidate, votes []VoteInput) PollResults {
	computeVotes := make([]PollComputeVote, len(votes))
	for i := 0; i < len(votes); i++ {
		computeVotes[i] = toComputeVote(votes[i])
	}
	return processPollStepsImpl(candidates, computeVotes)
}

func toComputeVote(vote VoteInput) PollComputeVote {
	candidateChoices := make([]string, len(vote.Choices))
	// Todo: this is garbage, actually check for this with proper mapping.
	for i := 0; i < len(vote.Choices); i++ {
		candidateChoices[vote.Choices[i].ChoicePosition] = vote.Choices[i].Candidate.Name
	}
	computeVote := PollComputeVote{candidateChoices}
	return computeVote
}

func processPollStepsImpl(candidates []Candidate, votes []PollComputeVote) PollResults {
	candidateMap := make(map[string]PollComputeCandidate)
	for _, candidate := range candidates {
		candidateMap[candidate.Name] = PollComputeCandidate{candidate, false, make([]PollComputeVote, 0)}
	}

	for true {
		candidateMap = iteratePoll(candidateMap, votes)
		pollStep := createPollResultStep(candidateMap)
		fmt.Printf("%d", pollStep.StepId)

		if isPollDone(candidateMap) {
			break
		}

		candidateMap = eliminateCandidates(candidateMap)

		// refresh candidateMap for the next iteration
		for name, candidate := range candidateMap {
			candidate.currentVotes = make([]PollComputeVote, 0)
			candidateMap[name] = candidate
		}

		// Sort PollVoteDistributionDataPoint s
	}

	return PollResults{}
}

func isPollDone(candidateMap map[string]PollComputeCandidate) bool {
	totalVotes := 0
	for _, candidate := range candidateMap {
		totalVotes += len(candidate.currentVotes)
	}

	for _, candidate := range candidateMap {
		if len(candidate.currentVotes) >= totalVotes/2.0 {
			return true
		}
	}

	return false
}

func iteratePoll(candidateMap map[string]PollComputeCandidate, votes []PollComputeVote) map[string]PollComputeCandidate {
	for _, vote := range votes {
		for _, choice := range vote.candidateChoices {
			if !candidateMap[choice].Eliminated {
				computeCandidate := candidateMap[choice]
				computeCandidate.currentVotes = append(computeCandidate.currentVotes, vote)
				candidateMap[choice] = computeCandidate
				break
			}
		}
	}

	return candidateMap
}

func getVoteDistribution(votes []PollComputeVote) []PollVoteDistributionDataPoint {
	distribMap := make(map[string]uint64)
	for _, vote := range votes {
		if _, ok := distribMap[vote.candidateChoices[0]]; ok {
			distribMap[vote.candidateChoices[0]] += 1
		} else {
			distribMap[vote.candidateChoices[0]] = 1
		}
	}

	dataPoints := make([]PollVoteDistributionDataPoint, 0)
	for key, value := range distribMap {
		dataPoints = append(dataPoints, PollVoteDistributionDataPoint{key, value})
	}

	return dataPoints
}

func createPollResultStep(candidateMap map[string]PollComputeCandidate) PollResultStep {

	return PollResultStep{}
}

func eliminateCandidates(candidateMap map[string]PollComputeCandidate) map[string]PollComputeCandidate {
	minVoteCount := math.MaxInt64
	for _, candidate := range candidateMap {
		if minVoteCount > len(candidate.currentVotes) {
			minVoteCount = len(candidate.currentVotes)
		}
	}

	for name, candidate := range candidateMap {
		if len(candidate.currentVotes) == minVoteCount {
			candidate.Eliminated = true
			candidateMap[name] = candidate
		}
	}

	return candidateMap
}
